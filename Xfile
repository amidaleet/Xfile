#!/usr/bin/env bash

if [ "$_OUTPUT_LINE_BUFFERED" != true ]; then
  export _OUTPUT_LINE_BUFFERED=true
  if command -v stdbuf >/dev/null; then exec stdbuf -oL -eL "$0" "$@"; fi
fi

set -eo pipefail

export GIT_ROOT="${GIT_ROOT:-"${PWD:-"$(pwd)"}"}"
export SCRIPTS_FOLDER="$GIT_ROOT/tools/sh"

source "$GIT_ROOT/Xfile_source/impl.sh"

link_child_xfile "$GIT_ROOT/Xfile_source/tests/tests.sh"
link_child_xfile "$SCRIPTS_FOLDER/git_x.sh"
link_child_xfile "$SCRIPTS_FOLDER/ruby_x.sh"
link_child_xfile "$SCRIPTS_FOLDER/brew_x.sh" brew:
link_child_xfile "$SCRIPTS_FOLDER/Xcode_x.sh" xcode:
link_child_xfile "$SCRIPTS_FOLDER/ios_runtime_x.sh" ios_runtime:
link_child_xfile "$SCRIPTS_FOLDER/jenkins_x.sh" jenkins_

if [ -f "$GIT_ROOT/usr/xprofile" ]; then source "$GIT_ROOT/usr/xprofile"; fi

export IS_CI=false
if [ -n "$JENKINS_HOME" ] || [ -n "$JENKINS_URL" ]; then IS_CI=true; fi

export FASTLANE_SKIP_UPDATE_CHECK=1
export FASTLANE_HIDE_CHANGELOG=1
export FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT=120

export OUTPUT_DIR="$GIT_ROOT/output"
TOOLS_DIR="$GIT_ROOT/tools"
RUBY_SCRIPTS_DIR="$GIT_ROOT/fastlane/scripts"
SWIFT_SCRIPTS_DIR="$TOOLS_DIR/swift/scripts"
GIT_HOOKS_DIR="$TOOLS_DIR/hooks"

# ---------- Setup ----------

function install_deps { ## Install required dependencies for development
  task brew:install_deps
  task install_python
  task install_ruby
  task gems_install
  task install_spm_deps
}

function install_ruby { ## Install Ruby version from .ruby-version file
  local ruby_version="$(cat .ruby-version)"
  task ruby_lang_installer --version "$ruby_version" --skip-existing
}

function install_python { ## Install Python version from .python-version file
  pyenv install --skip-existing
}

function install_spm_deps { ## Install Swift dependencies from Mintfile
  mint bootstrap
}

function setup { ## Prepare environment for development
  task setup_git
  task install_deps

  log_success "Setup finished!"
}

function setup_git { ## Configure git (hooks, LFS, config)
  # Custom git hooks changes hooksPath in local git config.
  # We need to do it before git-lfs setup, because lfs uses hooks too.
  task install_git_hooks

  log_info "Install git-lfs to local git"
  git lfs install --local --manual 1>/dev/null
  log "✅ git hooks have been set up above, you should not change them manually"

  log_info "Setting local config"
  git config --local lfs.locksverify true
  git config --local push.autoSetupRemote true

  log_info "Download files from LFS"
  git lfs pull
}

function install_git_hooks { ## Install helpful git hooks (branch name checker, add template commit message)
  "$GIT_HOOKS_DIR/make_hooks.sh"
}

# ---------- brew (CLI bins) ----------

function brew:install_ios_utils_from_repack {
  brew:check_dx_utils_env

  local mac_arch="${MY_ARCH:-"$(uname -m)"}"
  log_info "Detected mac arch: $mac_arch"

  local zip_path="$GIT_ROOT/output/bin_repack_${mac_arch}.zip"
  local repack_extraction_dir="$GIT_ROOT/output/bin_repack"

  log_warn "Loading is missing in this implementation!"
  log_next "Will unpack .zip from: $zip_path to: $repack_extraction_dir"
  rm -rf "$repack_extraction_dir"
  mkdir -p "$repack_extraction_dir"
  unzip -q "$zip_path" -d "$repack_extraction_dir"

  log_next "Will install utils for arch $mac_arch"

  rm -rf "${DX_SHELL_UTILS_DIR:?}"/{*,.*} || true
  mkdir -p "$DX_SHELL_UTILS_DIR"

  mv -v "$repack_extraction_dir"/* "$DX_SHELL_UTILS_DIR"
}

function brew:link_dylib_to_utils_dir {
  brew:check_dx_utils_env

  local mac_arch="${MY_ARCH:-"$(uname -m)"}"
  log_info "Detected mac arch: $mac_arch"

  local brew_dir
  case "${mac_arch}" in
    arm64)
      brew_dir='/opt/homebrew'
      ;;
    x86_64)
      brew_dir='/usr/local'
      ;;
    *)
      log_error 'Unknown macOS arch!'
      return 3
      ;;
  esac

  log_next "Will add symlinks to:" "$brew_dir"

  cd "$brew_dir"
  sudo ln -s "$DX_SHELL_UTILS_DIR/opt" opt
  sudo ln -s "$DX_SHELL_UTILS_DIR/lib" lib
}

function brew:check_dx_utils_env {
  log_info 'ENV is:' \
    "📌 DX_SHELL_UTILS_DIR" \
    "$DX_SHELL_UTILS_DIR" \
    "📌 PATH" \
    "$PATH"

  if [ -z "$DX_SHELL_UTILS_DIR" ]; then
    log_error "DX_SHELL_UTILS_DIR is missing in ENV"
    # shellcheck disable=SC2016
    log_info '.zprofile sample:' \
      '' \
      'export DX_SHELL_UTILS_DIR="$HOME/Development/dx_utils"' \
      'export PATH="$DX_SHELL_UTILS_DIR/bin:$PATH"' \
      ''
    return 64
  fi

  if [[ "$PATH" != *"$DX_SHELL_UTILS_DIR/bin:"* ]]; then
    log_error "DX_SHELL_UTILS_DIR is missing in PATH"
    # shellcheck disable=SC2016
    log_info '.zprofile sample:' \
      '' \
      'export DX_SHELL_UTILS_DIR="$HOME/Development/dx_utils"' \
      'export PATH="$DX_SHELL_UTILS_DIR/bin:$PATH"' \
      ''
    return 64
  fi
}

# ---------- Xcode ----------

## --dir
function xcode:patch_3rd_party_deps_for_arm64_simulator { ## Use arm64-to-sim to patch .xcframework sim arch in provided dir
  read_opt --dir deps_dir
  assert_defined deps_dir

  "$SCRIPTS_FOLDER/add_arm64_sim_archs.sh" "$deps_dir"
}

function xcode:set_header { ## Set org Xcode header template in user directory
  log_info "Set Xcode header template in ~/Library/Developer/Xcode/UserData/"
  cp "$TOOLS_DIR/xcode/IDETemplateMacros.plist" "$HOME/Library/Developer/Xcode/UserData/"

  log "✅ Updated template at: ~/Library/Developer/Xcode/UserData/, file: IDETemplateMacros.plist"
}

function remove_ios_simulators { ## Remove all iOS simulators from Xcode
  task fastlane remove_ios_simulators
}

function add_ios_simulator_for_tests { ## Add/Update targeted iOS simulator for tests in Workspace
  task fastlane add_ios_simulator_for_tests
}

function print_swift_test_results_json_for_analytics_event { ## Find test case total, fails and skips in logs Xcode test scheme run logs (out: json)
  task ruby_run "$RUBY_SCRIPTS_DIR/grep_swift_test_results.rb" \
    p_"$OUTPUT_DIR/test_pretty_logs/swift_tools_tests/out.log" \
    f_"$OUTPUT_DIR/test_pretty_logs/unit_tests/out.log" \
    f_"$OUTPUT_DIR/test_pretty_logs/snapshot_tests/out.log" \
    f_"$OUTPUT_DIR/test_pretty_logs/ui_tests/out.log" \
    f_"$OUTPUT_DIR/test_pretty_logs/performance_tests/out.log" \
    f_"$OUTPUT_DIR/test_pretty_logs/ui_essential_tests/out.log" \
    f_"$OUTPUT_DIR/test_pretty_logs/impact_tests/out.log"
}

function print_swift_errors_for_mattermost { ## Find test case total, fails and skips in logs Xcode test scheme run logs (out: Mattermost markdown)
  task ruby_run "$RUBY_SCRIPTS_DIR/grep_swift_errors.rb" \
    p_"$OUTPUT_DIR/test_pretty_logs/swift_tools_tests/err.log" \
    p_"$OUTPUT_DIR/test_pretty_logs/swift_tools_tests/out.log" \
    p_"$OUTPUT_DIR/test_pretty_logs/unit_tests/out.log" \
    p_"$OUTPUT_DIR/test_pretty_logs/snapshot_tests/out.log" \
    p_"$OUTPUT_DIR/test_pretty_logs/ui_tests/out.log" \
    p_"$OUTPUT_DIR/test_pretty_logs/performance_tests/out.log" \
    p_"$OUTPUT_DIR/test_pretty_logs/ui_essential_tests/out.log" \
    p_"$OUTPUT_DIR/test_pretty_logs/impact_tests/out.log" \
    "$1"
}

# ---------- Tools ----------

function test_tools { ## Run all tools unit tests
  task test_xfile
  task test_fastlane_tools
}

function test_fastlane_tools { ## Run fastlane unit tests
  log_info "Test fastlane actions"
  ruby_bundle exec rspec --pattern "tools/ruby/{**}/*_spec.rb"
}

# ---------- Lint & Format ----------

function format { ## Format modified files
  task format_swift
  task format_ruby
}

function format_swift { ## Format modified .swift files
  local filesArr=()

  for file in $(git diff --cached --name-only --diff-filter=ACM -- '*.swift'); do
    filesArr+=("$file")
  done

  if [[ "${#filesArr[@]}" -eq 0 ]]; then
    log "No .swift files to format"
    return
  fi

  mint run nicklockwood/SwiftFormat@0.53.4 \
    --config "$GIT_ROOT/.swiftformat.config" \
    --swiftversion "5.9" \
    "${filesArr[@]}"
}

function format_ruby { ## Format .rb files
  log_info "🚧 Format ruby with rubocop"
  task ruby_bundle exec rubocop -a --format simple
  log "✅ rubocop finished without offenses 🚧"
}

function lint {
  task lint_swift
  task lint_ruby
}

function lint_swift { ## Lint modified .swift files
  local filesArr=()

  for file in $(git diff --cached --name-only --diff-filter=ACM -- '*.swift'); do
    filesArr+=("$file")
  done

  if [[ "${#filesArr[@]}" -eq 0 ]]; then
    log "No .swift files to lint"
    return
  fi

  mint run realm/SwiftLint@0.54.0 lint \
    --config "$GIT_ROOT/.swiftlint.yml" \
    "${filesArr[@]}"
}

function lint_ruby { ## Lint all Ruby files
  task ruby_bundle exec rubocop --lint
}

# ---------- Agent information ----------

function get_os_name {
  "$SCRIPTS_FOLDER/get_os_name.sh"
}

function get_os_version {
  "$SCRIPTS_FOLDER/get_os_version.sh"
}

function bash_version { ## log bash version (which runs Xfile)
  puts "$BASH_VERSION"
}

# ---------- Xfile development ----------

function release_deploy {
  assert_semver "$1"

  task release_bump_ref_in_setup "$1"
  task release_zip_source_dir

  log_next "Will commit to and push release branch"
  task release_make_branch_if_major "$1"
  git add .
  git commit
  git push

  log_next "Will make and push $1 tag"
  git tag "$1"
  git push origin "$1"

  log_success "Pushed release $1"
  log_info "Should publish Github 'Release' manually"
}

function release_make_branch_if_major {
  assert_semver "$1"
  local current_branch release_branch_name
  current_branch=$(git branch --show-current)
  release_branch_name="release/${1%%.*}"

  if [ "${1#*.}" != '0.0' ]; then
    log_note "$1 is not a major release"
    if [ "$current_branch" != "$release_branch_name" ]; then
      log_error "Expected to be on existing $release_branch_name, but got:" "$current_branch"
      return 9
    fi
    log_next "Won't create new branch, will update current:" "$release_branch_name"
    return
  fi

  log_next "Will create and checkout $release_branch_name branch"
  git checkout -b "$release_branch_name"
}

function release_bump_ref_in_setup {
  assert_semver "$1"

  log_next "Will change version in:" Xfile_source/setup.sh README.md

  sed -i '' "s/{XFILE_REF:-.*}/{XFILE_REF:-$1}/1" ./Xfile_source/setup.sh
  sed -i '' "s/XFILE_REF='.*'/XFILE_REF='$1'/1" ./README.md
}

function release_zip_source_dir {
  log_next "Will zip ./Xfile_source to $OUTPUT_DIR/Xfile_source.zip"

  zip -r "$OUTPUT_DIR/Xfile_source.zip" ./Xfile_source
}

function assert_semver {
  if [[ ! "$1" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    log_error "Bad semver: $1"
    return 9
  fi
}

# ---------- Xfile override ----------

show_tasks() {
  show_tasks_from "$0"
  show_tasks_from_linked_children
  show_tasks_from Xfile_source/impl.sh "⚙️ impl functions:"
  show_tasks_from Xfile_source/xlib.sh "📚 xlib functions:"
  if [ -f usr/xprofile ]; then show_tasks_from usr/xprofile "👤 Personal xprofile tasks:"; fi
}

task_names() {
  show_task_names_from Xfile
  show_task_names_from_linked_children
  show_task_names_from Xfile_source/impl.sh
  show_task_names_from Xfile_source/xlib.sh
  if [ -f usr/xprofile ]; then show_task_names_from usr/xprofile; fi
}

task_args() {
  impl:task_args "$1" Xfile \
    || impl:task_args_in_linked_children "$1" \
    || impl:task_args "$1" Xfile_source/impl.sh \
    || impl:task_args "$1" Xfile_source/xlib.sh \
    || impl:task_args "$1" usr/xprofile
}

begin_xfile_task
